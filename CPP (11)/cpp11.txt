#1. 상속과 포인터
(1) 포인터가 가리킬 수 있는 대상
                  기초클래스 객체  파생클래스 객체
기초클래스 포인터         O               O
파생클래스 포인터         X               O


#2. 가상함수
(1) 정적연결
- 객체의 포인터(참조)에 의해 멤버함수를 호출할 경우 컴파일러가 포인터(참조)의 유형에 따라 호출할 멤버함수를 결정

(2) 동적연결
- 객체 포인터를 통해 객체의 멤버함수를 호출할 경우 포인터가 가리키는 실제 객체가 무엇인가에 따라 실행 중에 멤버함수를 결정하는 방법
- C++에서는 가상함수(virtual function)로 동적 연결을 구현함
- 기초 클래스에서 가상함수로 선언한 멤버함수를 파생 클래스에서 재정의하면 가상함수로 선언하지 않아도 가상함수임. 
(EX)
class Person{
  virtual void print() const{
    cout << name;
  }
}

class Student : public Person{
  void print() const{
    Person::print();
    cout << " goes to " << school;
  }
}

(3) 소멸자의 동적 연결
가. 소멸자를 가상함수로 선언하지 않는다면?
- 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 기초 클래스의 소멸자만 동작함
=> 파생클래스의 소멸자가 동작하지 않아 필요한 작업이 누락됨.
나. 소멸자를 가상함수로 선언
- 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 파생 클래스의 소멸자가 동작할 수 있게 함. 

다. 업 캐스팅
- 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것
- 자동 형변환을 통해 업 캐스팅을 할 수 있음
라.다운 캐스팅
- 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것
- 자동 형변환을 할 수 없으며, 형 변환 연산자를 통해 명시적으로 변환해야 함.